#!/usr/bin/env run-cargo-script
//! This is a regular crate doc comment, but it also contains a partial
//! Cargo manifest.  Note the use of a *fenced* code block, and the
//! `cargo` "language".
//!
//! ```cargo
//! [dependencies]
//! regex = "1.5.4"
//! serde_json = "1.0.66"
//!
//! [dependencies.serde]
//! version = "1.0.128"
//! features = ["derive"]
//!
//! [dependencies.ureq]
//! version = "2.1.1"
//! features = ["json"]
//! ```
extern crate regex;
extern crate serde;
extern crate serde_json;
extern crate ureq;

use regex::Regex;
use serde::{Deserialize, Serialize};
use serde_json::{self as json, Map, Value};
use std::{env, fs, io::{self, Write}};
use ureq::get;

#[derive(Deserialize, Serialize)]
struct Response {
    result: Vec<Update>
}

#[derive(Deserialize, Serialize)]
struct Update {
    #[serde(rename = "update_id")]
    id: u32,

    #[serde(flatten)]
    rest: Map<String, Value>
}

fn read_option(path: &str) -> io::Result<Option<String>> {
    match fs::read_to_string(path) {
        Ok(ok) => Ok(Some(ok)),
        Err(err) if err.kind() == io::ErrorKind::NotFound => Ok(None),
        Err(err) => Err(err)
    }
}

struct FieldReplacer(Vec<(Regex, String)>);

impl FieldReplacer {
    fn new(field: &str, re: &str, dummy: &str) -> Self {
        Self(Vec::new()).chain(field, re, dummy)
    }

    fn apply(&self, mut on: String) -> String {
        for (regex, dummy) in &self.0 {
            on = regex.replace_all(&on, dummy).into_owned();
        }
        on
    }

    fn chain(mut self, field: &str, re: &str, dummy: &str) -> FieldReplacer {
        self.0.push((
            Regex::new(&format!(r#""{}":{}"#, field, re)).unwrap(),
            format!(r#""{}":{}"#, field, dummy)
        ));
        self
    }
}

fn main() {
    let token = env::var("TOKEN").unwrap();
    let offset: u32 = read_option("offset").unwrap()
        .map_or(Ok(0), |s| s.parse()).unwrap();

    let resp = get(&format!("https://api.telegram.org/bot{}/getUpdates", token))
        .query("offset", &offset.to_string())
        .call().unwrap();
    let resp: Response = resp.into_json().unwrap();
    
    let shred = FieldReplacer::new("first_name", r#""\w*""#, r#""FIRST_NAME""#)
        .chain("last_name", r#""\w*""#, r#""LAST_NAME""#)
        .chain("id", r#"\-?[0-9]+"#, "123456")
        .chain("username", r#""\w*""#, r#""USERNAME""#);

    for upd in resp.result {
        fs::write("offset", &(upd.id + 1).to_string()).unwrap();

        let raw = format!(
            "#\n{}\n",
            json::to_string(&upd).unwrap()
        );
        let safe = shred.apply(raw);
    
        fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open("updates").unwrap()
            .write_all(safe.as_bytes()).unwrap();
    }
}
